<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>js篇 | 随心所欲</title>
    <meta name="generator" content="VuePress 1.9.7">
    
    <meta name="description" content="自律、自信、坚持，加油">
    
    <link rel="preload" href="/blog/assets/css/0.styles.4cd9b374.css" as="style"><link rel="preload" href="/blog/assets/js/app.51cc0803.js" as="script"><link rel="preload" href="/blog/assets/js/3.c67a96f6.js" as="script"><link rel="preload" href="/blog/assets/js/1.d0a14e8e.js" as="script"><link rel="preload" href="/blog/assets/js/14.7e662a00.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.67bc0086.js"><link rel="prefetch" href="/blog/assets/js/11.0694bcd1.js"><link rel="prefetch" href="/blog/assets/js/12.f6fb423f.js"><link rel="prefetch" href="/blog/assets/js/13.4fff0fcc.js"><link rel="prefetch" href="/blog/assets/js/4.1a72345b.js"><link rel="prefetch" href="/blog/assets/js/5.6d99caa7.js"><link rel="prefetch" href="/blog/assets/js/6.14cd16ee.js"><link rel="prefetch" href="/blog/assets/js/7.ccd676ba.js"><link rel="prefetch" href="/blog/assets/js/8.11230af2.js"><link rel="prefetch" href="/blog/assets/js/9.691937b5.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.4cd9b374.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar" data-v-5bb33761><div data-v-5bb33761><div class="password-shadow password-wrapper-out" style="display:none;" data-v-59e6cb88 data-v-5bb33761 data-v-5bb33761><h3 class="title" data-v-59e6cb88>随心所欲</h3> <p class="description" data-v-59e6cb88>自律、自信、坚持，加油</p> <label id="box" class="inputBox" data-v-59e6cb88><input type="password" value="" data-v-59e6cb88> <span data-v-59e6cb88>Konck! Knock!</span> <button data-v-59e6cb88>OK</button></label> <div class="footer" data-v-59e6cb88><span data-v-59e6cb88><i class="iconfont reco-theme" data-v-59e6cb88></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-59e6cb88>vuePress-theme-reco</a></span> <span data-v-59e6cb88><i class="iconfont reco-copyright" data-v-59e6cb88></i> <a data-v-59e6cb88><span data-v-59e6cb88>沈</span>
          
        <!---->
        2022
      </a></span></div></div> <div class="hide" data-v-5bb33761><header class="navbar" data-v-5bb33761><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><img src="/blog/assets/head.jpeg" alt="随心所欲" class="logo"> <span class="site-name">随心所欲</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/" class="nav-link"><i class="iconfont reco-home"></i>
  Home
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      分类
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/categories/游览器/" class="nav-link"><i class="undefined"></i>
  游览器
</a></li><li class="dropdown-item"><!----> <a href="/blog/categories/HTML/" class="nav-link"><i class="undefined"></i>
  HTML
</a></li><li class="dropdown-item"><!----> <a href="/blog/categories/js/" class="nav-link"><i class="undefined"></i>
  js
</a></li><li class="dropdown-item"><!----> <a href="/blog/categories/CSS/" class="nav-link"><i class="undefined"></i>
  CSS
</a></li></ul></div></div><div class="nav-item"><a href="/blog/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  标签
</a></div><div class="nav-item"><a href="/blog/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  TimeLine
</a></div><div class="nav-item"><a href="https://github.com/Shenjunku" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-github"></i>
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-5bb33761></div> <aside class="sidebar" data-v-5bb33761><div class="personal-info-wrapper" data-v-1fad0c41 data-v-5bb33761><img src="/blog/assets/head.jpeg" alt="author-avatar" class="personal-img" data-v-1fad0c41> <h3 class="name" data-v-1fad0c41>
    沈
  </h3> <div class="num" data-v-1fad0c41><div data-v-1fad0c41><h3 data-v-1fad0c41>4</h3> <h6 data-v-1fad0c41>Articles</h6></div> <div data-v-1fad0c41><h3 data-v-1fad0c41>1</h3> <h6 data-v-1fad0c41>Tags</h6></div></div> <ul class="social-links" data-v-1fad0c41><li class="social-item" data-v-1fad0c41><i class="iconfont reco-github" style="color:#849b87;" data-v-1fad0c41></i></li><li class="social-item" data-v-1fad0c41><i class="iconfont reco-npm" style="color:#f8b26a;" data-v-1fad0c41></i></li></ul> <hr data-v-1fad0c41></div> <nav class="nav-links"><div class="nav-item"><a href="/blog/" class="nav-link"><i class="iconfont reco-home"></i>
  Home
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      分类
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/categories/游览器/" class="nav-link"><i class="undefined"></i>
  游览器
</a></li><li class="dropdown-item"><!----> <a href="/blog/categories/HTML/" class="nav-link"><i class="undefined"></i>
  HTML
</a></li><li class="dropdown-item"><!----> <a href="/blog/categories/js/" class="nav-link"><i class="undefined"></i>
  js
</a></li><li class="dropdown-item"><!----> <a href="/blog/categories/CSS/" class="nav-link"><i class="undefined"></i>
  CSS
</a></li></ul></div></div><div class="nav-item"><a href="/blog/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  标签
</a></div><div class="nav-item"><a href="/blog/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  TimeLine
</a></div><div class="nav-item"><a href="https://github.com/Shenjunku" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-github"></i>
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav> <!----> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-59e6cb88 data-v-5bb33761><h3 class="title" data-v-59e6cb88>js篇</h3> <!----> <label id="box" class="inputBox" data-v-59e6cb88><input type="password" value="" data-v-59e6cb88> <span data-v-59e6cb88>Konck! Knock!</span> <button data-v-59e6cb88>OK</button></label> <div class="footer" data-v-59e6cb88><span data-v-59e6cb88><i class="iconfont reco-theme" data-v-59e6cb88></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-59e6cb88>vuePress-theme-reco</a></span> <span data-v-59e6cb88><i class="iconfont reco-copyright" data-v-59e6cb88></i> <a data-v-59e6cb88><span data-v-59e6cb88>沈</span>
          
        <!---->
        2022
      </a></span></div></div> <div data-v-5bb33761><div data-v-5bb33761><main class="page"><section style="display:;"><div class="page-title"><h1 class="title">js篇</h1> <div data-v-8a445198><i class="iconfont reco-account" data-v-8a445198><span data-v-8a445198>沈</span></i> <i class="iconfont reco-date" data-v-8a445198><span data-v-8a445198>8/2/2022</span></i> <!----> <i class="tags iconfont reco-tag" data-v-8a445198><span class="tag-item" data-v-8a445198>面试</span></i></div></div> <div class="theme-reco-content content__default"><h3 id="javascript"><a href="#javascript" class="header-anchor">#</a> JavaScript</h3> <h4 id="var、let、-const的区别"><a href="#var、let、-const的区别" class="header-anchor">#</a> var、let、 const的区别</h4> <p>var 变量提升</p> <div class="language- extra-class"><pre class="language-text"><code>var a='沈'
等于下方的代码
var a;
a=沈;
</code></pre></div><p>let 禁止重复声明,不存在变量提升，具有块级作用域</p> <p>const 具有let的特性，声明的基本类型后不能改变值，但是如果是引用类型可以修改其中的属性</p> <h5 id="var-声明的变量挂在window-let和const声明的不在window-所以let-和const不存在变量提升-let-和const存储在语法环境-var-存储在变量环境这是它们之间存在差异的原因"><a href="#var-声明的变量挂在window-let和const声明的不在window-所以let-和const不存在变量提升-let-和const存储在语法环境-var-存储在变量环境这是它们之间存在差异的原因" class="header-anchor">#</a> var 声明的变量挂在window,let和const声明的不在window,所以let 和const不存在变量提升，let 和const存储在语法环境,var 存储在变量环境这是它们之间存在差异的原因</h5> <p>没有用var声明的变量都是全局变量，而且是顶层对象的属性</p> <h5 id="执行上下文"><a href="#执行上下文" class="header-anchor">#</a> 执行上下文</h5> <p>执行上下文是当前 JavaScript 代码被解析和执行时所在环境的抽象概念</p> <div class="language- extra-class"><pre class="language-text"><code>ExecutionContext = {  
  ThisBinding = &lt;this value&gt;,     // 确定this 
  LexicalEnvironment = { ... },   // 词法环境
  VariableEnvironment = { ... },  // 变量环境
}
在 ES6 中，词法 环境和 变量 环境的区别在于前者用于存储**函数声明和变量（ let 和 const ）绑定，而后者仅用于存储变量（ var ）**绑定
</code></pre></div><h4 id="数据类型"><a href="#数据类型" class="header-anchor">#</a> 数据类型</h4> <p>原始类型：string、number、boolean、null、undefined、symbol(ES10 BigInt)</p> <p>引用类型:object(function、array)</p> <h5 id="判断数据类型"><a href="#判断数据类型" class="header-anchor">#</a> 判断数据类型</h5> <ul><li>typeof主要判断原始类型，但是不能将Object、Array和Null区分，都返回object；</li> <li>instanceof主要判断引用类型，能够区分Array、Object和Function，但是Number，Boolean，String基本数据类型不能判断</li> <li>Object.prototype.toString.call()可以判断所有类型</li></ul> <h5 id="null和undefined的区别"><a href="#null和undefined的区别" class="header-anchor">#</a> null和undefined的区别</h5> <p>undefined类型只有一个值，即undefined</p> <ul><li>变量被声明了，但没有赋值时，就等于undefined。</li> <li>调用函数时，应该提供的参数没有提供，该参数等于undefined。</li> <li>对象没有赋值的属性，该属性的值为undefined。</li> <li>函数没有返回值时，默认返回undefined。</li></ul> <p>Null类型也只有一个值，即null。null用来表示尚未存在的对象,常用来表示函数企图返回一个不存在的对象。</p> <ul><li>作为函数的参数，表示该函数的参数不是对象。</li> <li>作为对象原型链的终点。</li></ul> <h4 id="定义函数的方法"><a href="#定义函数的方法" class="header-anchor">#</a> 定义函数的方法</h4> <h5 id="函数声明"><a href="#函数声明" class="header-anchor">#</a> 函数声明</h5> <div class="language- extra-class"><pre class="language-text"><code>//ES5
function getSum(){}
</code></pre></div><h5 id="函数表达式"><a href="#函数表达式" class="header-anchor">#</a> 函数表达式</h5> <div class="language- extra-class"><pre class="language-text"><code>//ES5
var getSum=function(){}
//ES6
let getSum=()=&gt;{}
</code></pre></div><h5 id="构造函数"><a href="#构造函数" class="header-anchor">#</a> 构造函数</h5> <div class="language- extra-class"><pre class="language-text"><code>const getSum = new Function('a', 'b' , 'return a + b')
</code></pre></div><table><thead><tr><th><strong>特征</strong></th> <th>函数声明</th> <th>函数表达式</th></tr></thead> <tbody><tr><td>预提升</td> <td>会进行预提升</td> <td>不会进行预提升</td></tr> <tr><td>访问范围</td> <td>函数内部和函数父级作用域</td> <td>函数内部</td></tr> <tr><td>函数名</td> <td>不能没有</td> <td>可以没有</td></tr></tbody></table> <div class="language- extra-class"><pre class="language-text"><code> test() //正常访问
 function test(){}  //预提升
 
 cs()   //报错
 let cs=function test1(){}
 cs()    //正常使用
 test1()  //不能访问，所以报错
</code></pre></div><h4 id="作用域和作用域链"><a href="#作用域和作用域链" class="header-anchor">#</a> 作用域和作用域链</h4> <p><strong>作用域指的是您有权访问的变量集合</strong>作用域分为全局作用域、块级作用域、函数作用域</p> <h5 id="作用域链"><a href="#作用域链" class="header-anchor">#</a> 作用域链</h5> <p>当可执行代码内部访问变量时，会先查找本地作用域，如果找到目标变量即返回，否则会去父级作用域继续查找...一直找到全局作用域。我们把这种作用域的嵌套机制，称为 作用域链。</p> <h4 id="闭包"><a href="#闭包" class="header-anchor">#</a> 闭包</h4> <p>一个函数访问另一个函数内的变量， 一般都是函数嵌套函数形成闭包，</p> <p>为什么闭包还能访问到变量，因为闭包的变量不存在栈内存，而是保存在堆内存里</p> <h5 id="闭包的优点"><a href="#闭包的优点" class="header-anchor">#</a> 闭包的优点</h5> <h5 id="闭包的缺点"><a href="#闭包的缺点" class="header-anchor">#</a> 闭包的缺点</h5> <p>会导致函数的变量一直保存在内存中，过多的闭包可能会导致内存泄漏</p> <h5 id="闭包的使用场景"><a href="#闭包的使用场景" class="header-anchor">#</a> 闭包的使用场景</h5> <ul><li><p>函数作为参数被传递和返回值被返回</p></li> <li><p>单例模式</p> <div class="language- extra-class"><pre class="language-text"><code>单例模式是一种常见的涉及模式，它保证了一个类只有一个实例。实现方法一般是先判断实例是否存在，如果存在就直接返回，否则就创建了再返回。单例模式的好处就是避免了重复实例化带来的内存开销
// 单例模式
function Singleton(){
  this.data = 'singleton';
}

Singleton.getInstance = (function () {
  var instance;
    
  return function(){
    if (instance) {
      return instance;
    } else {
      instance = new Singleton();
      return instance;
    }
  }
})();

var sa = Singleton.getInstance();
var sb = Singleton.getInstance();
console.log(sa === sb); // true
console.log(sa.data); // 'singleton'
</code></pre></div></li> <li><p>封装私有属性和方法</p> <div class="language- extra-class"><pre class="language-text"><code>// 模拟私有属性
function getGeneratorFunc () {
  var _name = 'John';
  var _age = 22;
    
  return function () {
    return {
      getName: function () {return _name;},
      getAge: function() {return _age;}
    };
  };
}

var obj = getGeneratorFunc()();
obj.getName(); // John
obj.getAge(); // 22
obj._age; // undefined
</code></pre></div></li></ul> <h4 id="this指向"><a href="#this指向" class="header-anchor">#</a> this指向</h4> <ul><li><p>默认绑定: 非严格模式下 this 指向全局对象，严格模式下 this 会绑定为 undefined</p></li> <li><p>隐式绑定: 满足 XXX.fn() 格式，fn 的 this 指向 XXX。如果存在链式调用， this 永远指向最后调用它的那个对象 隐式绑定丢失：起函数别名，通过别名运行；函数作为参数会造成隐式绑定丢失。</p> <div class="language- extra-class"><pre class="language-text"><code>   
   function foo1() {
        console.log(this.a);
    }
    function foo3() {
        console.log(this.a);
    }
    var obj = {
        a: 2,
        b:{
          a:1,
          foo: foo1
        },
       foo:foo3
    };

    obj.b.foo(); // 1
    obj.foo() //2
</code></pre></div></li> <li><p>显式绑定: 通过 call/apply/bind 修改 this 指向</p></li> <li><p>new绑定: 通过 new 来调用构造函数，会生成一个新对象，并且把这个新对象绑定为调用函数的 this（this指向这个新对象）。</p></li> <li><p>箭头函数绑定: 箭头函数没有 this ，箭头函数的 this 始终指向函数定义时的 this，而非执行时</p> <div class="language- extra-class"><pre class="language-text"><code>var name = &quot;windowsName&quot;;

    var a = {
        name : &quot;Cherry&quot;,

        func1: function () {
            console.log(this.name)     
        },

        func2: function () {
            setTimeout( () =&gt; {
                this.func1()
            },100);
        }

    };

    a.func2()     // Cherry
</code></pre></div><p>按照下方也可以理解</p></li></ul> <ol><li>函数调用，当一个函数不是一个对象的属性时，直接作为函数来调用时，<code>this</code>指向全局对象。</li> <li>方法调用，如果一个函数作为一个对象的方法来调用时，<code>this</code>指向这个对象。</li> <li>构造函数调用，<code>this</code>指向这个用<code>new</code>新创建的对象。</li> <li>第四种是 <code>apply 、 call 和 bind</code>调用模式，这三个方法都可以显示的指定调用函数的 this 指向。<code>apply</code>接收参数的是数组，<code>call</code>接受参数列表，`` bind<code>方法通过传入一个对象，返回一个</code> this <code>绑定了传入对象的新函数。这个函数的</code>this<code>指向除了使用</code>new `时会被改变，其他情况下都不会改变。</li></ol> <h5 id="new关键字"><a href="#new关键字" class="header-anchor">#</a> new关键字</h5> <p>1、创建一个新的空对象</p> <div class="language- extra-class"><pre class="language-text"><code>var obj={}
</code></pre></div><p>2、设置新对象的原型__proto__属性指向构造函数的pototype对象</p> <div class="language- extra-class"><pre class="language-text"><code>obj.__proto__=Class.prototype
</code></pre></div><p>3、构造函数的this赋值给新对象（即this指向新对象）</p> <div class="language- extra-class"><pre class="language-text"><code>var ret=Class.apply(obj,arguments)
</code></pre></div><p>4、判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">return</span> ret <span class="token keyword">instanceof</span> <span class="token class-name">Object</span> <span class="token operator">?</span> ret <span class="token operator">:</span> obj<span class="token punctuation">;</span>
</code></pre></div><h4 id="call、apply和bind的区别"><a href="#call、apply和bind的区别" class="header-anchor">#</a> call、apply和bind的区别</h4> <h5 id="作用"><a href="#作用" class="header-anchor">#</a> 作用</h5> <ul><li>改变函数内部的<code>this</code></li> <li>这三个函数都是<code>函数对象</code>的方法，也就是说只有函数才可以直接调用这些方法。</li></ul> <p><code>apply</code>和<code>call</code>的区别是<code>call</code>方法接受的是若干个参数列表，而<code>apply</code>接收的是一个包含多个参数的数组。</p> <div class="language- extra-class"><pre class="language-text"><code>fun.call(thisArg[, arg1[, arg2[, ...]]])
fun.apply(thisArg, [argsArray])
立即执行
</code></pre></div><p>而bind()方法创建一个新的函数, 当被调用时，将其this关键字设置为提供的值，在调用新函数时，在任何提供之前提供一个给定的参数序列。</p> <div class="language- extra-class"><pre class="language-text"><code>var bindFn = fun.bind(thisArg[, arg1[, arg2[, ...]]])
bindFn()
可以自己确定什么时候执行
</code></pre></div><h5 id="使用场景"><a href="#使用场景" class="header-anchor">#</a> 使用场景</h5> <p>call继承</p> <div class="language- extra-class"><pre class="language-text"><code>function person(name){
    this.name = name
}
function man(name){
    this.age = '男';
    person.call(this,name);              // 继承 man
}
var me = new man('海洋饼干');

console.log(me.name,me.age);             // '海洋饼干' '男'
</code></pre></div><p>合并数组 apply()</p> <div class="language- extra-class"><pre class="language-text"><code>var a = [1,2,3];
var b = [4,5,6];
[].push.apply(a,b);    // 借用数组的push方法 等价 a.push(4,5,6);
console.log(a);        // [1, 2, 3, 4, 5, 6]
</code></pre></div><p>取数组的最大值和最小值apply()</p> <div class="language- extra-class"><pre class="language-text"><code>var num = [6,9,-3,-5];
console.log(Math.max.apply(Math,num)); // 9  等价  console.log(Math.max(6,9,-3,-5));
console.log(Math.min.apply(Math,num)); // -5 等价  console.log(Math.min(6,9,-3,-5));
</code></pre></div><p>可以将一个类似（伪）数组的对象（比如arguments对象）转为真正的数组apply()</p> <div class="language- extra-class"><pre class="language-text"><code>var ArrayLike = { // 一个类似数组的对象
    0: 'a',
    1: 'b',
    2: 'c',
    length: 3
}
//接收的是对象，返回的是数组
Array.prototype.slice.apply({0: 1, length: 1}) // [1]
Array.prototype.slice.apply({0: 1}) // []
Array.prototype.slice.apply({0: 1, length: 2}) // [1, undefined]
Array.prototype.slice.apply({length: 1}) // [undefined]
//（切下）[].slice(1, n)，返回索引为1到索引为n-1的数组
</code></pre></div><p>bind绑定</p> <div class="language- extra-class"><pre class="language-text"><code>var fun ;
var obj = {
    a : 1,
    foo : function(){            // 不使用 _this， 避免无谓的变量声明
        fun = function(){
            console.log(this.a);
        }.bind(this);            // 代码很简洁,很漂亮（b格）
    }
}
var obj1 = { a : 2}
obj.foo();
fun();             // 1
fun.call(obj1);    // 1  call ,apply等绑定 无法修改
                   // 这里和上面call的位置不同是因为this所处于不同的位置
</code></pre></div><h5 id="原型和原型链"><a href="#原型和原型链" class="header-anchor">#</a> 原型和原型链</h5> <p>原型是一个对象，里面是一些属性和方法，每个对象都有隐式原型__proto__属性,该属性指向它的构造函数的显示原型prototype属性</p> <div class="language- extra-class"><pre class="language-text"><code>  let  cat={
        name:'喵喵'
    }
    cat.__proto__.eat=function(){
        console.log('吃鱼')
    }
    cat.eat() //吃鱼
    function Dog(name,age){
        this.name=name;
        this.age=age
    }
    let dog=new Dog('小黄',2)
    Dog.prototype.eat=function(){
        console.log('吃骨头')
    }
    dog.eat() //吃骨头
</code></pre></div><h5 id="原型链"><a href="#原型链" class="header-anchor">#</a> 原型链</h5> <p>如果你去某个对象查找一个不存在的属性和方法，那么它就会去隐式原型__proto__（或者构造函数的显示原型prototype）去寻找上方的  ，寻找的过程就是原型链</p> <div class="language- extra-class"><pre class="language-text"><code>    //原型继承
    function User(username,password){
        this.username=username;
        this.password=password;
       this.login=function(){
            console.log('登录')
        }
    }
    function Admin(){
        this.deletePerson=function(){
            console.log('删除用户')
        }
    }
    Admin.prototype=new User();
    let admin=new Admin();
    admin.login() //登录
    
    admin并没有login方法，他便向__proto上去寻找，admin.__proto__等于Admin.prototype,Admin的原型等于User,在User中找到了login方法，向上寻找的过程形成了原型链
</code></pre></div><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c631b657ca62427a8bdef1a2c145346a~tplv-k3u1fbpfcp-watermark.awebp" alt="image.png"></p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/adede89e51c04a2b90beef8cb1cb848d~tplv-k3u1fbpfcp-watermark.awebp" alt="img"></p> <p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1ead8002adf6487ba7c080c81029e1e3~tplv-k3u1fbpfcp-watermark.awebp" alt="img"></p> <p>原型链的顶层是Object，Object.prototype的隐式原型指向null,为了避免死循环而设置</p> <h4 id="js运行机制详解-event-loop"><a href="#js运行机制详解-event-loop" class="header-anchor">#</a> js运行机制详解（Event Loop）</h4> <p>js引擎存在monitoring process进程，会持续不断的检查主线程执行栈是否为空，一旦为空，就会去Event Queue那里检查是否有等待被调用的函数。这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop（事件循环）</p> <p>所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）；</p> <h5 id="同步任务"><a href="#同步任务" class="header-anchor">#</a> 同步任务</h5> <p>在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；</p> <h5 id="异步任务"><a href="#异步任务" class="header-anchor">#</a> 异步任务</h5> <p>不进入主线程、而进入&quot;任务队列&quot;（task queue）的任务，只有&quot;任务队列&quot;通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。</p> <h5 id="宏任务-or-微任务"><a href="#宏任务-or-微任务" class="header-anchor">#</a> 宏任务 or 微任务</h5> <p>这里需要注意的是new Promise是会进入到主线程中立刻执行，而promise.then则属于微任务</p> <ul><li>宏任务(macro-task)：整体代码script、setTimeOut、setInterval</li> <li>微任务(mincro-task)：promise.then、promise.nextTick(node)</li></ul> <p><img src="https://upload-images.jianshu.io/upload_images/4820992-82913323252fde95.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/863/format/webp" alt="img"></p> <h5 id="事件冒泡"><a href="#事件冒泡" class="header-anchor">#</a> 事件冒泡</h5> <p>事件冒泡可以形象地比喻为把一颗石头投入水中，泡泡会一直从水底冒出水面。也就是说，事件会从最内层的元素开始发生，一直向上传播，直到document对象。</p> <p>以下是事件冒泡的执行顺序</p> <p><strong>p -&gt; div -&gt; body -&gt; html -&gt; document</strong></p> <h5 id="阻止冒泡"><a href="#阻止冒泡" class="header-anchor">#</a> 阻止冒泡</h5> <ul><li>event.stopPropagation(); // 一般浏览器停止冒泡</li> <li>event.cancelBubble; // IE 6 7 8 的停止冒泡</li></ul> <h5 id="事件捕捉"><a href="#事件捕捉" class="header-anchor">#</a> 事件捕捉</h5> <p>与事件冒泡相反，事件会从最外层开始发生，直到最具体的元素。</p> <p>以下是事件捕捉的执行顺序</p> <p><strong>document -&gt; html -&gt; body -&gt; div -&gt; p</strong></p> <h5 id="事件委托"><a href="#事件委托" class="header-anchor">#</a> 事件委托</h5> <p>事件委托是利用的事件冒泡的原理，把事件绑定到需要处理元素的父亲元素上，如果要给下方的li绑定事件，每个都需要绑定，如果绑定给ul父元素，只用绑定一次，只操作了一次 DOM ，提高了程序的性能。</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;ul&gt;
    &lt;li&gt;111&lt;/li&gt;
    &lt;li&gt;222&lt;/li&gt;
    &lt;li&gt;333&lt;/li&gt;
    &lt;li&gt;444&lt;/li&gt;
&lt;/ul&gt;
</code></pre></div><h4 id="原生ajax"><a href="#原生ajax" class="header-anchor">#</a> 原生ajax</h4> <p><strong>ajax</strong>是一种异步通信的方法,从服务端获取数据,达到局部刷新页面的效果。 过程：</p> <ol><li>创建<code>XMLHttpRequest</code>对象;</li> <li>调用<code>open</code>方法传入三个参数 请求方式<code>(GET/POST)、url、同步异步(true/false)</code>;</li> <li>监听<code>onreadystatechange</code>事件，当<code>readystate</code>等于4时返回<code>responseText</code>;</li> <li>调用send方法传递参数。</li></ol> <div class="language- extra-class"><pre class="language-text"><code> function ajaxHttpRequestFunc(){
		let xmlHttpRequest;  // 创建XMLHttpRequest对象，即一个用于保存异步调用对象的变量
		if(window.ActiveXObject){ // IE浏览器的创建方式
            xmlHttpRequest = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);
        }else if(window.XMLHttpRequest){ // Netscape浏览器中的创建方式
            xmlHttpRequest = new XMLHttpRequest();
        }
		xmlHttpRequest.onreadystatechange=function(){ // 设置响应http请求状态变化的事件
            console.log('请求过程', xmlHttpRequest.readyState);
			if(xmlHttpRequest.readyState == 4){ // 判断异步调用是否成功,若成功开始局部更新数据
				console.log('状态码为', xmlHttpRequest.status);
				if(xmlHttpRequest.status == 200) {
					console.log('异步调用返回的数据为：', xmlHttpRequest .responseText);
					document.getElementById(&quot;myDiv&quot;).innerHTML = xmlHttpRequest .responseText; // 局部刷新数据到页面
				} else { // 如果异步调用未成功,弹出警告框,并显示错误状态码
					alert(&quot;error:HTTP状态码为:&quot;+xmlHttpRequest.status);
				}
			}
		}
		xmlHttpRequest.open(&quot;GET&quot;,&quot;https://www.runoob.com/try/ajax/ajax_info.txt&quot;,true); // 创建http请求，并指定请求得方法（get）、url（https://www.runoob.com/try/ajax/ajax_info.txt）以及验证信息
		xmlHttpRequest.send(null); // 发送请求
    }

</code></pre></div><h5 id="js中map和foreach的区别"><a href="#js中map和foreach的区别" class="header-anchor">#</a> JS中Map和ForEach的区别:</h5> <p>forEach()方法不会返回执行结果，而是undefined。也就是说，forEach()会修改原来的数组
而map()方法会得到一个新的数组并返回。</p> <h5 id="改变数组的方法"><a href="#改变数组的方法" class="header-anchor">#</a> 改变数组的方法</h5> <ul><li>splice()</li> <li>sort()</li> <li>pop()</li> <li>shift()</li> <li>unshift()</li> <li>push()</li> <li>reverse()</li></ul> <h5 id="不改变数组的方法"><a href="#不改变数组的方法" class="header-anchor">#</a> 不改变数组的方法</h5> <ul><li>slice()</li> <li>join()</li> <li>toString()</li> <li>cancat()</li> <li>indexOf()</li> <li>lastIndexOf()</li></ul> <h5 id="遍历数组的方法"><a href="#遍历数组的方法" class="header-anchor">#</a> 遍历数组的方法</h5> <ul><li>forEach()</li> <li>every() 检测数组所有元素是否都符合判断条件,返回true false</li> <li>some()  数组中的是否有满足判断条件的元素,返回true false</li> <li>map() 对数组中的每个元素进行处理，返回新的数组</li> <li>filter() 过滤原始数组，返回新数组</li> <li>reduce()  为数组提供累加器，合并为一个值</li></ul> <h4 id="浏览器从输入url到渲染页面-发生了什么"><a href="#浏览器从输入url到渲染页面-发生了什么" class="header-anchor">#</a> 浏览器从输入url到渲染页面，发生了什么？</h4> <h5 id="通过dns解析域名的实际ip地址"><a href="#通过dns解析域名的实际ip地址" class="header-anchor">#</a> 通过DNS解析域名的实际IP地址</h5> <h5 id="检查浏览器是否有缓存"><a href="#检查浏览器是否有缓存" class="header-anchor">#</a> 检查浏览器是否有缓存</h5> <h5 id="与服务器建立-tcp-连接。"><a href="#与服务器建立-tcp-连接。" class="header-anchor">#</a> 与服务器建立 TCP 连接。</h5> <h5 id="发送http请求"><a href="#发送http请求" class="header-anchor">#</a> 发送HTTP请求</h5> <h5 id="服务器处理请求并返回"><a href="#服务器处理请求并返回" class="header-anchor">#</a> 服务器处理请求并返回</h5> <h5 id="浏览器解析渲染页面"><a href="#浏览器解析渲染页面" class="header-anchor">#</a> 浏览器解析渲染页面</h5> <ul><li>解析HTML形成DOM树</li> <li>解析CSS形成CSSOM 树</li> <li>合并DOM树和CSSOM树形成渲染树</li> <li>浏览器开始渲染并绘制页面</li></ul></div></section> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated: </span> <span class="time">8/3/2022, 5:14:27 PM</span></div></footer> <!----> <div class="comments-wrapper"><!----></div> <ul class="side-bar sub-sidebar-wrapper" style="width:12rem;" data-v-ac050c62><li class="level-3" data-v-ac050c62><a href="/blog/view/%E9%9D%A2%E8%AF%95/js.html#javascript" class="sidebar-link reco-side-javascript" data-v-ac050c62>JavaScript</a></li></ul></main></div> <!----></div></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-c6073ba8 data-v-c6073ba8><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-c6073ba8><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-c6073ba8></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-c6073ba8></path></svg></div></div></div>
    <script src="/blog/assets/js/app.51cc0803.js" defer></script><script src="/blog/assets/js/3.c67a96f6.js" defer></script><script src="/blog/assets/js/1.d0a14e8e.js" defer></script><script src="/blog/assets/js/14.7e662a00.js" defer></script>
  </body>
</html>
