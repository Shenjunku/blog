(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{415:function(t,a,e){"use strict";e.r(a);var n=e(2),s=Object(n.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h3",{attrs:{id:"javascript"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#javascript"}},[t._v("#")]),t._v(" JavaScript")]),t._v(" "),a("h4",{attrs:{id:"var、let、-const的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#var、let、-const的区别"}},[t._v("#")]),t._v(" var、let、 const的区别")]),t._v(" "),a("p",[t._v("var 变量提升")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("var a='沈'\n等于下方的代码\nvar a;\na=沈;\n")])])]),a("p",[t._v("let 禁止重复声明,不存在变量提升，具有块级作用域")]),t._v(" "),a("p",[t._v("const 具有let的特性，声明的基本类型后不能改变值，但是如果是引用类型可以修改其中的属性")]),t._v(" "),a("h5",{attrs:{id:"var-声明的变量挂在window-let和const声明的不在window-所以let-和const不存在变量提升-let-和const存储在语法环境-var-存储在变量环境这是它们之间存在差异的原因"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#var-声明的变量挂在window-let和const声明的不在window-所以let-和const不存在变量提升-let-和const存储在语法环境-var-存储在变量环境这是它们之间存在差异的原因"}},[t._v("#")]),t._v(" var 声明的变量挂在window,let和const声明的不在window,所以let 和const不存在变量提升，let 和const存储在语法环境,var 存储在变量环境这是它们之间存在差异的原因")]),t._v(" "),a("p",[t._v("没有用var声明的变量都是全局变量，而且是顶层对象的属性")]),t._v(" "),a("h5",{attrs:{id:"执行上下文"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#执行上下文"}},[t._v("#")]),t._v(" 执行上下文")]),t._v(" "),a("p",[t._v("执行上下文是当前 JavaScript 代码被解析和执行时所在环境的抽象概念")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("ExecutionContext = {  \n  ThisBinding = <this value>,     // 确定this \n  LexicalEnvironment = { ... },   // 词法环境\n  VariableEnvironment = { ... },  // 变量环境\n}\n在 ES6 中，词法 环境和 变量 环境的区别在于前者用于存储**函数声明和变量（ let 和 const ）绑定，而后者仅用于存储变量（ var ）**绑定\n")])])]),a("h4",{attrs:{id:"数据类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数据类型"}},[t._v("#")]),t._v(" 数据类型")]),t._v(" "),a("p",[t._v("原始类型：string、number、boolean、null、undefined、symbol(ES10 BigInt)")]),t._v(" "),a("p",[t._v("引用类型:object(function、array)")]),t._v(" "),a("h5",{attrs:{id:"判断数据类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#判断数据类型"}},[t._v("#")]),t._v(" 判断数据类型")]),t._v(" "),a("ul",[a("li",[t._v("typeof主要判断原始类型，但是不能将Object、Array和Null区分，都返回object；")]),t._v(" "),a("li",[t._v("instanceof主要判断引用类型，能够区分Array、Object和Function，但是Number，Boolean，String基本数据类型不能判断")]),t._v(" "),a("li",[t._v("Object.prototype.toString.call()可以判断所有类型")])]),t._v(" "),a("h5",{attrs:{id:"null和undefined的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#null和undefined的区别"}},[t._v("#")]),t._v(" null和undefined的区别")]),t._v(" "),a("p",[t._v("undefined类型只有一个值，即undefined")]),t._v(" "),a("ul",[a("li",[t._v("变量被声明了，但没有赋值时，就等于undefined。")]),t._v(" "),a("li",[t._v("调用函数时，应该提供的参数没有提供，该参数等于undefined。")]),t._v(" "),a("li",[t._v("对象没有赋值的属性，该属性的值为undefined。")]),t._v(" "),a("li",[t._v("函数没有返回值时，默认返回undefined。")])]),t._v(" "),a("p",[t._v("Null类型也只有一个值，即null。null用来表示尚未存在的对象,常用来表示函数企图返回一个不存在的对象。")]),t._v(" "),a("ul",[a("li",[t._v("作为函数的参数，表示该函数的参数不是对象。")]),t._v(" "),a("li",[t._v("作为对象原型链的终点。")])]),t._v(" "),a("h4",{attrs:{id:"定义函数的方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#定义函数的方法"}},[t._v("#")]),t._v(" 定义函数的方法")]),t._v(" "),a("h5",{attrs:{id:"函数声明"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#函数声明"}},[t._v("#")]),t._v(" 函数声明")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("//ES5\nfunction getSum(){}\n")])])]),a("h5",{attrs:{id:"函数表达式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#函数表达式"}},[t._v("#")]),t._v(" 函数表达式")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("//ES5\nvar getSum=function(){}\n//ES6\nlet getSum=()=>{}\n")])])]),a("h5",{attrs:{id:"构造函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#构造函数"}},[t._v("#")]),t._v(" 构造函数")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("const getSum = new Function('a', 'b' , 'return a + b')\n")])])]),a("table",[a("thead",[a("tr",[a("th",[a("strong",[t._v("特征")])]),t._v(" "),a("th",[t._v("函数声明")]),t._v(" "),a("th",[t._v("函数表达式")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("预提升")]),t._v(" "),a("td",[t._v("会进行预提升")]),t._v(" "),a("td",[t._v("不会进行预提升")])]),t._v(" "),a("tr",[a("td",[t._v("访问范围")]),t._v(" "),a("td",[t._v("函数内部和函数父级作用域")]),t._v(" "),a("td",[t._v("函数内部")])]),t._v(" "),a("tr",[a("td",[t._v("函数名")]),t._v(" "),a("td",[t._v("不能没有")]),t._v(" "),a("td",[t._v("可以没有")])])])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v(" test() //正常访问\n function test(){}  //预提升\n \n cs()   //报错\n let cs=function test1(){}\n cs()    //正常使用\n test1()  //不能访问，所以报错\n")])])]),a("h4",{attrs:{id:"作用域和作用域链"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#作用域和作用域链"}},[t._v("#")]),t._v(" 作用域和作用域链")]),t._v(" "),a("p",[a("strong",[t._v("作用域指的是您有权访问的变量集合")]),t._v("作用域分为全局作用域、块级作用域、函数作用域")]),t._v(" "),a("h5",{attrs:{id:"作用域链"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#作用域链"}},[t._v("#")]),t._v(" 作用域链")]),t._v(" "),a("p",[t._v("当可执行代码内部访问变量时，会先查找本地作用域，如果找到目标变量即返回，否则会去父级作用域继续查找...一直找到全局作用域。我们把这种作用域的嵌套机制，称为 作用域链。")]),t._v(" "),a("h4",{attrs:{id:"闭包"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#闭包"}},[t._v("#")]),t._v(" 闭包")]),t._v(" "),a("p",[t._v("一个函数访问另一个函数内的变量， 一般都是函数嵌套函数形成闭包，")]),t._v(" "),a("p",[t._v("为什么闭包还能访问到变量，因为闭包的变量不存在栈内存，而是保存在堆内存里")]),t._v(" "),a("h5",{attrs:{id:"闭包的优点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#闭包的优点"}},[t._v("#")]),t._v(" 闭包的优点")]),t._v(" "),a("h5",{attrs:{id:"闭包的缺点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#闭包的缺点"}},[t._v("#")]),t._v(" 闭包的缺点")]),t._v(" "),a("p",[t._v("会导致函数的变量一直保存在内存中，过多的闭包可能会导致内存泄漏")]),t._v(" "),a("h5",{attrs:{id:"闭包的使用场景"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#闭包的使用场景"}},[t._v("#")]),t._v(" 闭包的使用场景")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("函数作为参数被传递和返回值被返回")])]),t._v(" "),a("li",[a("p",[t._v("单例模式")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("单例模式是一种常见的涉及模式，它保证了一个类只有一个实例。实现方法一般是先判断实例是否存在，如果存在就直接返回，否则就创建了再返回。单例模式的好处就是避免了重复实例化带来的内存开销\n// 单例模式\nfunction Singleton(){\n  this.data = 'singleton';\n}\n\nSingleton.getInstance = (function () {\n  var instance;\n    \n  return function(){\n    if (instance) {\n      return instance;\n    } else {\n      instance = new Singleton();\n      return instance;\n    }\n  }\n})();\n\nvar sa = Singleton.getInstance();\nvar sb = Singleton.getInstance();\nconsole.log(sa === sb); // true\nconsole.log(sa.data); // 'singleton'\n")])])])]),t._v(" "),a("li",[a("p",[t._v("封装私有属性和方法")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("// 模拟私有属性\nfunction getGeneratorFunc () {\n  var _name = 'John';\n  var _age = 22;\n    \n  return function () {\n    return {\n      getName: function () {return _name;},\n      getAge: function() {return _age;}\n    };\n  };\n}\n\nvar obj = getGeneratorFunc()();\nobj.getName(); // John\nobj.getAge(); // 22\nobj._age; // undefined\n")])])])])]),t._v(" "),a("h4",{attrs:{id:"this指向"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#this指向"}},[t._v("#")]),t._v(" this指向")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("默认绑定: 非严格模式下 this 指向全局对象，严格模式下 this 会绑定为 undefined")])]),t._v(" "),a("li",[a("p",[t._v("隐式绑定: 满足 XXX.fn() 格式，fn 的 this 指向 XXX。如果存在链式调用， this 永远指向最后调用它的那个对象 隐式绑定丢失：起函数别名，通过别名运行；函数作为参数会造成隐式绑定丢失。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("   \n   function foo1() {\n        console.log(this.a);\n    }\n    function foo3() {\n        console.log(this.a);\n    }\n    var obj = {\n        a: 2,\n        b:{\n          a:1,\n          foo: foo1\n        },\n       foo:foo3\n    };\n\n    obj.b.foo(); // 1\n    obj.foo() //2\n")])])])]),t._v(" "),a("li",[a("p",[t._v("显式绑定: 通过 call/apply/bind 修改 this 指向")])]),t._v(" "),a("li",[a("p",[t._v("new绑定: 通过 new 来调用构造函数，会生成一个新对象，并且把这个新对象绑定为调用函数的 this（this指向这个新对象）。")])]),t._v(" "),a("li",[a("p",[t._v("箭头函数绑定: 箭头函数没有 this ，箭头函数的 this 始终指向函数定义时的 this，而非执行时")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('var name = "windowsName";\n\n    var a = {\n        name : "Cherry",\n\n        func1: function () {\n            console.log(this.name)     \n        },\n\n        func2: function () {\n            setTimeout( () => {\n                this.func1()\n            },100);\n        }\n\n    };\n\n    a.func2()     // Cherry\n')])])]),a("p",[t._v("按照下方也可以理解")])])]),t._v(" "),a("ol",[a("li",[t._v("函数调用，当一个函数不是一个对象的属性时，直接作为函数来调用时，"),a("code",[t._v("this")]),t._v("指向全局对象。")]),t._v(" "),a("li",[t._v("方法调用，如果一个函数作为一个对象的方法来调用时，"),a("code",[t._v("this")]),t._v("指向这个对象。")]),t._v(" "),a("li",[t._v("构造函数调用，"),a("code",[t._v("this")]),t._v("指向这个用"),a("code",[t._v("new")]),t._v("新创建的对象。")]),t._v(" "),a("li",[t._v("第四种是 "),a("code",[t._v("apply 、 call 和 bind")]),t._v("调用模式，这三个方法都可以显示的指定调用函数的 this 指向。"),a("code",[t._v("apply")]),t._v("接收参数的是数组，"),a("code",[t._v("call")]),t._v("接受参数列表，`` bind"),a("code",[t._v("方法通过传入一个对象，返回一个")]),t._v(" this "),a("code",[t._v("绑定了传入对象的新函数。这个函数的")]),t._v("this"),a("code",[t._v("指向除了使用")]),t._v("new `时会被改变，其他情况下都不会改变。")])]),t._v(" "),a("h5",{attrs:{id:"new关键字"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#new关键字"}},[t._v("#")]),t._v(" new关键字")]),t._v(" "),a("p",[t._v("1、创建一个新的空对象")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("var obj={}\n")])])]),a("p",[t._v("2、设置新对象的原型__proto__属性指向构造函数的pototype对象")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("obj.__proto__=Class.prototype\n")])])]),a("p",[t._v("3、构造函数的this赋值给新对象（即this指向新对象）")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("var ret=Class.apply(obj,arguments)\n")])])]),a("p",[t._v("4、判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" ret "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("instanceof")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Object")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("?")]),t._v(" ret "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" obj"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("h4",{attrs:{id:"call、apply和bind的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#call、apply和bind的区别"}},[t._v("#")]),t._v(" call、apply和bind的区别")]),t._v(" "),a("h5",{attrs:{id:"作用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#作用"}},[t._v("#")]),t._v(" 作用")]),t._v(" "),a("ul",[a("li",[t._v("改变函数内部的"),a("code",[t._v("this")])]),t._v(" "),a("li",[t._v("这三个函数都是"),a("code",[t._v("函数对象")]),t._v("的方法，也就是说只有函数才可以直接调用这些方法。")])]),t._v(" "),a("p",[a("code",[t._v("apply")]),t._v("和"),a("code",[t._v("call")]),t._v("的区别是"),a("code",[t._v("call")]),t._v("方法接受的是若干个参数列表，而"),a("code",[t._v("apply")]),t._v("接收的是一个包含多个参数的数组。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("fun.call(thisArg[, arg1[, arg2[, ...]]])\nfun.apply(thisArg, [argsArray])\n立即执行\n")])])]),a("p",[t._v("而bind()方法创建一个新的函数, 当被调用时，将其this关键字设置为提供的值，在调用新函数时，在任何提供之前提供一个给定的参数序列。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("var bindFn = fun.bind(thisArg[, arg1[, arg2[, ...]]])\nbindFn()\n可以自己确定什么时候执行\n")])])]),a("h5",{attrs:{id:"使用场景"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用场景"}},[t._v("#")]),t._v(" 使用场景")]),t._v(" "),a("p",[t._v("call继承")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("function person(name){\n    this.name = name\n}\nfunction man(name){\n    this.age = '男';\n    person.call(this,name);              // 继承 man\n}\nvar me = new man('海洋饼干');\n\nconsole.log(me.name,me.age);             // '海洋饼干' '男'\n")])])]),a("p",[t._v("合并数组 apply()")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("var a = [1,2,3];\nvar b = [4,5,6];\n[].push.apply(a,b);    // 借用数组的push方法 等价 a.push(4,5,6);\nconsole.log(a);        // [1, 2, 3, 4, 5, 6]\n")])])]),a("p",[t._v("取数组的最大值和最小值apply()")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("var num = [6,9,-3,-5];\nconsole.log(Math.max.apply(Math,num)); // 9  等价  console.log(Math.max(6,9,-3,-5));\nconsole.log(Math.min.apply(Math,num)); // -5 等价  console.log(Math.min(6,9,-3,-5));\n")])])]),a("p",[t._v("可以将一个类似（伪）数组的对象（比如arguments对象）转为真正的数组apply()")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("var ArrayLike = { // 一个类似数组的对象\n    0: 'a',\n    1: 'b',\n    2: 'c',\n    length: 3\n}\n//接收的是对象，返回的是数组\nArray.prototype.slice.apply({0: 1, length: 1}) // [1]\nArray.prototype.slice.apply({0: 1}) // []\nArray.prototype.slice.apply({0: 1, length: 2}) // [1, undefined]\nArray.prototype.slice.apply({length: 1}) // [undefined]\n//（切下）[].slice(1, n)，返回索引为1到索引为n-1的数组\n")])])]),a("p",[t._v("bind绑定")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("var fun ;\nvar obj = {\n    a : 1,\n    foo : function(){            // 不使用 _this， 避免无谓的变量声明\n        fun = function(){\n            console.log(this.a);\n        }.bind(this);            // 代码很简洁,很漂亮（b格）\n    }\n}\nvar obj1 = { a : 2}\nobj.foo();\nfun();             // 1\nfun.call(obj1);    // 1  call ,apply等绑定 无法修改\n                   // 这里和上面call的位置不同是因为this所处于不同的位置\n")])])]),a("h5",{attrs:{id:"原型和原型链"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#原型和原型链"}},[t._v("#")]),t._v(" 原型和原型链")]),t._v(" "),a("p",[t._v("原型是一个对象，里面是一些属性和方法，每个对象都有隐式原型__proto__属性,该属性指向它的构造函数的显示原型prototype属性")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("  let  cat={\n        name:'喵喵'\n    }\n    cat.__proto__.eat=function(){\n        console.log('吃鱼')\n    }\n    cat.eat() //吃鱼\n    function Dog(name,age){\n        this.name=name;\n        this.age=age\n    }\n    let dog=new Dog('小黄',2)\n    Dog.prototype.eat=function(){\n        console.log('吃骨头')\n    }\n    dog.eat() //吃骨头\n")])])]),a("h5",{attrs:{id:"原型链"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#原型链"}},[t._v("#")]),t._v(" 原型链")]),t._v(" "),a("p",[t._v("如果你去某个对象查找一个不存在的属性和方法，那么它就会去隐式原型__proto__（或者构造函数的显示原型prototype）去寻找上方的  ，寻找的过程就是原型链")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("    //原型继承\n    function User(username,password){\n        this.username=username;\n        this.password=password;\n       this.login=function(){\n            console.log('登录')\n        }\n    }\n    function Admin(){\n        this.deletePerson=function(){\n            console.log('删除用户')\n        }\n    }\n    Admin.prototype=new User();\n    let admin=new Admin();\n    admin.login() //登录\n    \n    admin并没有login方法，他便向__proto上去寻找，admin.__proto__等于Admin.prototype,Admin的原型等于User,在User中找到了login方法，向上寻找的过程形成了原型链\n")])])]),a("p",[a("img",{attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c631b657ca62427a8bdef1a2c145346a~tplv-k3u1fbpfcp-watermark.awebp",alt:"image.png"}})]),t._v(" "),a("p",[a("img",{attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/adede89e51c04a2b90beef8cb1cb848d~tplv-k3u1fbpfcp-watermark.awebp",alt:"img"}})]),t._v(" "),a("p",[a("img",{attrs:{src:"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1ead8002adf6487ba7c080c81029e1e3~tplv-k3u1fbpfcp-watermark.awebp",alt:"img"}})]),t._v(" "),a("p",[t._v("原型链的顶层是Object，Object.prototype的隐式原型指向null,为了避免死循环而设置")]),t._v(" "),a("h4",{attrs:{id:"js运行机制详解-event-loop"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#js运行机制详解-event-loop"}},[t._v("#")]),t._v(" js运行机制详解（Event Loop）")]),t._v(" "),a("p",[t._v("js引擎存在monitoring process进程，会持续不断的检查主线程执行栈是否为空，一旦为空，就会去Event Queue那里检查是否有等待被调用的函数。这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop（事件循环）")]),t._v(" "),a("p",[t._v("所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）；")]),t._v(" "),a("h5",{attrs:{id:"同步任务"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#同步任务"}},[t._v("#")]),t._v(" 同步任务")]),t._v(" "),a("p",[t._v("在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；")]),t._v(" "),a("h5",{attrs:{id:"异步任务"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#异步任务"}},[t._v("#")]),t._v(" 异步任务")]),t._v(" "),a("p",[t._v('不进入主线程、而进入"任务队列"（task queue）的任务，只有"任务队列"通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。')]),t._v(" "),a("h5",{attrs:{id:"宏任务-or-微任务"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#宏任务-or-微任务"}},[t._v("#")]),t._v(" 宏任务 or 微任务")]),t._v(" "),a("p",[t._v("这里需要注意的是new Promise是会进入到主线程中立刻执行，而promise.then则属于微任务")]),t._v(" "),a("ul",[a("li",[t._v("宏任务(macro-task)：整体代码script、setTimeOut、setInterval")]),t._v(" "),a("li",[t._v("微任务(mincro-task)：promise.then、promise.nextTick(node)")])]),t._v(" "),a("p",[a("img",{attrs:{src:"https://upload-images.jianshu.io/upload_images/4820992-82913323252fde95.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/863/format/webp",alt:"img"}})]),t._v(" "),a("h5",{attrs:{id:"事件冒泡"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#事件冒泡"}},[t._v("#")]),t._v(" 事件冒泡")]),t._v(" "),a("p",[t._v("事件冒泡可以形象地比喻为把一颗石头投入水中，泡泡会一直从水底冒出水面。也就是说，事件会从最内层的元素开始发生，一直向上传播，直到document对象。")]),t._v(" "),a("p",[t._v("以下是事件冒泡的执行顺序")]),t._v(" "),a("p",[a("strong",[t._v("p -> div -> body -> html -> document")])]),t._v(" "),a("h5",{attrs:{id:"阻止冒泡"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#阻止冒泡"}},[t._v("#")]),t._v(" 阻止冒泡")]),t._v(" "),a("ul",[a("li",[t._v("event.stopPropagation(); // 一般浏览器停止冒泡")]),t._v(" "),a("li",[t._v("event.cancelBubble; // IE 6 7 8 的停止冒泡")])]),t._v(" "),a("h5",{attrs:{id:"事件捕捉"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#事件捕捉"}},[t._v("#")]),t._v(" 事件捕捉")]),t._v(" "),a("p",[t._v("与事件冒泡相反，事件会从最外层开始发生，直到最具体的元素。")]),t._v(" "),a("p",[t._v("以下是事件捕捉的执行顺序")]),t._v(" "),a("p",[a("strong",[t._v("document -> html -> body -> div -> p")])]),t._v(" "),a("h5",{attrs:{id:"事件委托"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#事件委托"}},[t._v("#")]),t._v(" 事件委托")]),t._v(" "),a("p",[t._v("事件委托是利用的事件冒泡的原理，把事件绑定到需要处理元素的父亲元素上，如果要给下方的li绑定事件，每个都需要绑定，如果绑定给ul父元素，只用绑定一次，只操作了一次 DOM ，提高了程序的性能。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("<ul>\n    <li>111</li>\n    <li>222</li>\n    <li>333</li>\n    <li>444</li>\n</ul>\n")])])]),a("h4",{attrs:{id:"原生ajax"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#原生ajax"}},[t._v("#")]),t._v(" 原生ajax")]),t._v(" "),a("p",[a("strong",[t._v("ajax")]),t._v("是一种异步通信的方法,从服务端获取数据,达到局部刷新页面的效果。 过程：")]),t._v(" "),a("ol",[a("li",[t._v("创建"),a("code",[t._v("XMLHttpRequest")]),t._v("对象;")]),t._v(" "),a("li",[t._v("调用"),a("code",[t._v("open")]),t._v("方法传入三个参数 请求方式"),a("code",[t._v("(GET/POST)、url、同步异步(true/false)")]),t._v(";")]),t._v(" "),a("li",[t._v("监听"),a("code",[t._v("onreadystatechange")]),t._v("事件，当"),a("code",[t._v("readystate")]),t._v("等于4时返回"),a("code",[t._v("responseText")]),t._v(";")]),t._v(" "),a("li",[t._v("调用send方法传递参数。")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v(' function ajaxHttpRequestFunc(){\n\t\tlet xmlHttpRequest;  // 创建XMLHttpRequest对象，即一个用于保存异步调用对象的变量\n\t\tif(window.ActiveXObject){ // IE浏览器的创建方式\n            xmlHttpRequest = new ActiveXObject("Microsoft.XMLHTTP");\n        }else if(window.XMLHttpRequest){ // Netscape浏览器中的创建方式\n            xmlHttpRequest = new XMLHttpRequest();\n        }\n\t\txmlHttpRequest.onreadystatechange=function(){ // 设置响应http请求状态变化的事件\n            console.log(\'请求过程\', xmlHttpRequest.readyState);\n\t\t\tif(xmlHttpRequest.readyState == 4){ // 判断异步调用是否成功,若成功开始局部更新数据\n\t\t\t\tconsole.log(\'状态码为\', xmlHttpRequest.status);\n\t\t\t\tif(xmlHttpRequest.status == 200) {\n\t\t\t\t\tconsole.log(\'异步调用返回的数据为：\', xmlHttpRequest .responseText);\n\t\t\t\t\tdocument.getElementById("myDiv").innerHTML = xmlHttpRequest .responseText; // 局部刷新数据到页面\n\t\t\t\t} else { // 如果异步调用未成功,弹出警告框,并显示错误状态码\n\t\t\t\t\talert("error:HTTP状态码为:"+xmlHttpRequest.status);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\txmlHttpRequest.open("GET","https://www.runoob.com/try/ajax/ajax_info.txt",true); // 创建http请求，并指定请求得方法（get）、url（https://www.runoob.com/try/ajax/ajax_info.txt）以及验证信息\n\t\txmlHttpRequest.send(null); // 发送请求\n    }\n\n')])])]),a("h5",{attrs:{id:"js中map和foreach的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#js中map和foreach的区别"}},[t._v("#")]),t._v(" JS中Map和ForEach的区别:")]),t._v(" "),a("p",[t._v("forEach()方法不会返回执行结果，而是undefined。也就是说，forEach()会修改原来的数组\n而map()方法会得到一个新的数组并返回。")]),t._v(" "),a("h5",{attrs:{id:"改变数组的方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#改变数组的方法"}},[t._v("#")]),t._v(" 改变数组的方法")]),t._v(" "),a("ul",[a("li",[t._v("splice()")]),t._v(" "),a("li",[t._v("sort()")]),t._v(" "),a("li",[t._v("pop()")]),t._v(" "),a("li",[t._v("shift()")]),t._v(" "),a("li",[t._v("unshift()")]),t._v(" "),a("li",[t._v("push()")]),t._v(" "),a("li",[t._v("reverse()")])]),t._v(" "),a("h5",{attrs:{id:"不改变数组的方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#不改变数组的方法"}},[t._v("#")]),t._v(" 不改变数组的方法")]),t._v(" "),a("ul",[a("li",[t._v("slice()")]),t._v(" "),a("li",[t._v("join()")]),t._v(" "),a("li",[t._v("toString()")]),t._v(" "),a("li",[t._v("cancat()")]),t._v(" "),a("li",[t._v("indexOf()")]),t._v(" "),a("li",[t._v("lastIndexOf()")])]),t._v(" "),a("h5",{attrs:{id:"遍历数组的方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#遍历数组的方法"}},[t._v("#")]),t._v(" 遍历数组的方法")]),t._v(" "),a("ul",[a("li",[t._v("forEach()")]),t._v(" "),a("li",[t._v("every() 检测数组所有元素是否都符合判断条件,返回true false")]),t._v(" "),a("li",[t._v("some()  数组中的是否有满足判断条件的元素,返回true false")]),t._v(" "),a("li",[t._v("map() 对数组中的每个元素进行处理，返回新的数组")]),t._v(" "),a("li",[t._v("filter() 过滤原始数组，返回新数组")]),t._v(" "),a("li",[t._v("reduce()  为数组提供累加器，合并为一个值")])]),t._v(" "),a("h4",{attrs:{id:"浏览器从输入url到渲染页面-发生了什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#浏览器从输入url到渲染页面-发生了什么"}},[t._v("#")]),t._v(" 浏览器从输入url到渲染页面，发生了什么？")]),t._v(" "),a("h5",{attrs:{id:"通过dns解析域名的实际ip地址"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#通过dns解析域名的实际ip地址"}},[t._v("#")]),t._v(" 通过DNS解析域名的实际IP地址")]),t._v(" "),a("h5",{attrs:{id:"检查浏览器是否有缓存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#检查浏览器是否有缓存"}},[t._v("#")]),t._v(" 检查浏览器是否有缓存")]),t._v(" "),a("h5",{attrs:{id:"与服务器建立-tcp-连接。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#与服务器建立-tcp-连接。"}},[t._v("#")]),t._v(" 与服务器建立 TCP 连接。")]),t._v(" "),a("h5",{attrs:{id:"发送http请求"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#发送http请求"}},[t._v("#")]),t._v(" 发送HTTP请求")]),t._v(" "),a("h5",{attrs:{id:"服务器处理请求并返回"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#服务器处理请求并返回"}},[t._v("#")]),t._v(" 服务器处理请求并返回")]),t._v(" "),a("h5",{attrs:{id:"浏览器解析渲染页面"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#浏览器解析渲染页面"}},[t._v("#")]),t._v(" 浏览器解析渲染页面")]),t._v(" "),a("ul",[a("li",[t._v("解析HTML形成DOM树")]),t._v(" "),a("li",[t._v("解析CSS形成CSSOM 树")]),t._v(" "),a("li",[t._v("合并DOM树和CSSOM树形成渲染树")]),t._v(" "),a("li",[t._v("浏览器开始渲染并绘制页面")])])])}),[],!1,null,null,null);a.default=s.exports}}]);